# Решение задачи "Верификация функции проверки прав доступа на Frama-C"

Все комментарии по предлагаемому решению внесены в исходный код.
Проще всего их посмотреть, сравнив решение с исходным файлом.

Существенные комментарии приведены ниже:
  
1. В задании указано
    ```
    compute_mask вычисляет маску (с битами MAY_WRITE и MAY_READ) ...
    доступы в маске означают наличие прав соответствующего доступа
    ```

    Поэтому вызывает вопрос, почему в следующем участке исходного кода
    возвращается `0`, а не `(MAY_READ | MAY_WRITE)`:
    ```С
    // Проверяем, является ли файл публичным.
    // Если да, то доступ разрешен сразу
    if (inode->i_flags & SHIFT)
        return 0;
    ```

    Решение, предполагающее, что опечатка в комментарии, и "разрешен" надо читать "запрешён", приведено в файле с номером 1. Решение, предполагающее, что опечатка в коде (а комментарий верный), приведено в файле с номером 2.

2. Ошибка, о которой есть предупреждение в задании, заключается в отсутствии проверки, что текущему процессу уже назначена метка. В её отсутствие доступ не должен предоставляться. При этом функция `check_permission` может вернуть `-NO_PERM`. Вместо этого предлагаемое решение использует код возврата `-NO_LABEL` для более точной диагностики. При необходимости код и спецификации легко адаптировать, если всё же надо использовать код возврата `-NO_PERM`.

3. В спецификациях решения используются разделы, подробно описывающие поведение функций. Это может быть использовано для дальнейшего анализа, а также помочь верифицировать клиентов этих функций. Если подробное описание не нужно, достаточно исключить из спецификаций разделы `behavior`. Их удаление не влияет на результат верификации.

4. Исходные спецификации содержат недочёты. В частности, `assigns \nothing` в `file_inode` и `getCurrentLabel` были заменены на `assigns \result \from ...`, чтобы сообщить инструменту, указатели на какие блоки памяти эти функции могут возвращать.

5. В исходном коде содержится синтаксическая ошибка в определении функции `file_inode`.

6. В исходном коде для проверки корректности обращения к памяти используется встроенный предикат `\valid`. Все функции являются "чистыми", т.е. не изменяют значения переданных аргуметов (в том числе черед вложенные указатели) и глобальных переменных. Поэтому разумно вместо `\valid` использовать `\valid_read`.
