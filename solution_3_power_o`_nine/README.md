## Уровень 1

В рамках решения первого уровня наша команда нашла две неисправности в модели autotune_full.pml и три в модели autotune_reduced.pml;
Модель autotune_full.pml содержит в себе следующие неисправности:
- Процесс pex обновляет start_time не в том месте (перепутаны соседние строки, см. autotune_full.pml :81).
- Модель некорректно обрабатывает синхронизацию потоков (экземпляров процесса `pex`). В частности, если хотя бы 2 процесса `pex` имеют различную длину выполняемой работы, после которой стоит барьер, то при завершении более "короткого" процесса и его перехода в "режим ожидания" условие инкремента глобального времени никогда не выполнится. Происходит это вследствие того, что по достижению "коротким" процессом барьера, этот процесс не увеличивает переменную `NRP_work`, сброшенную в 0 таймером (процесс `clock`) на предыдущем тике, а это, в свою очередь, ведёт к тому, что условие инкремента `NRP_work == allNWE` никогда не выполнится. Процесс, первым дошедший до барьера, никогда не "внесёт" себя в `NRP_work`. Более длинный процесс, ожидающий выполнения `work_step`, никогда не дождется. Формально говоря, происходит deadlock и глобальное время останавливается. 
Ниже приведен исходный код из репозитория, в него внесены минимальные изменения, которые приводят к deadlock'у:

```Promela
proctype pex (byte me; chan pex_b; chan b_pex; chan pex_u; chan u_pex) { 
  ...
  do 
    :: u_pex ? go ->
      atomic { 
        start_time = time;
        cur_time = time;
      }
      for (i : 0 .. size/TS-1) { 
        ...
        start_time = time;
            if 
              // Изменение в строке ниже
              :: me % 2 -> long_work(2) // 'if' access to local memory
              :: else -> long_work(1)   // 'else' access to local memory
            fi;
        pex_b ! done;		 
        b_pex ? go;   // waiting for local co-workers  
      }
      ...
      pex_u ! done;  
    :: u_pex ? stop -> break;
  od;
}
```
- Нюанс есть и с тем, как идет время внутри процесса `pex`. Исходя из логикы работы long_work, есть смысл после выполнения такой работы обновлять `start_time` (присваивать `start_time` значение `current_time`), однако, этого не делается. Поэтому, если в коде есть теоретическая возможность двух последовательных выполнений `long_work`, между которыми не будет обновлена переменная `start_time`, глобальное время может не увеличиться корректно;
- Отсутствие моделирования размера тайла (`TS`). При равных значениях `WG` модель с меньшим размером тайла должна исполнять больше экземпляров work item'ов (элементов work group'ы). Однако, это нигде не учитывается, поэтому, если бы не специфика исходного OpenCL кода (в одном цикле значение `TS` увеличивает его длину, а в другом цикле уменьшает), то модель всегда бы выбирала минимально возможный `TS`. К сожалению, осознание этого пришло к нашей команде в районе десяти вечера последнего дня хакатона, поэтому мы не сумели вовремя смоделировать корректное поведение. По этой причине наша модель стремиться выбрать минимальный `TS`, а так как `TS` никак не связан с `WG`, `WG` подбирается по такой же логике. Таким образом, отсутствует моделирование специфики работы с памятью, которое должно влечь за собой изменение параметра `TS`. 


Модель autotune_reduced.pml включает в себя:
- Все вышеописанные неисправности модели autotune_full.pml;
- Небольшую опечатку - в описании указано, что данная модель обладает одной единицей device и этот device обладает единственным unit'ом. Исходя из значений соответствующих переменных, можно убедиться, что это не так:
```Promela
active proctype main() { 
  byte d;

  NP = 4;		// the number of processing elements per unit
  NU = 2;		// the number of units per device
  ND = 1;		// the number of devices
  ...
}
```

Мы предложили следующее решение второй проблемы - добавить глобальную переменную `NRP_waiting`, которую будет увеличивать процесс `barrier`, когда ему придет сигнал о том, что какой-то процесс `pex` достиг барьера. Когда все процессы дойдут до барьера, процесс `barrier` уменьшит число ожидающих процессов и отошлет всем `pex` сообщение `go`. Условие инкремента глобального времени было изменено:
```Promela
// было
NRP_work == allNWE && allNWE != 0
// стало
NRP_work == allNWE - NRP_wait && allNWE != 0 && NRP_wait != allNWE
```
Если все процессы во всех unit'ах ждут, то таймер надо остановить и подождать, пока barrier уменьшит число ждущих процессов.

Как уже было сказано, мы не смогли поправить все проблемы исходной модели, отчасти поэтому и не смогли продвинуться дальше первого этапа. Тем не менее, набросок кода для работы с warp'ами присутствует.

### **Таблицы с результатами работы модели для задачи первого уровня, а также UML-диаграммы, можно найти в файле tables.md**

---
