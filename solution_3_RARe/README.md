# -veha2024

## 1-й уровень ([level_1](level_1))

Для решения задачи первого уровня был взят авторский вариант модели поиска
минимума: [min.pml].

Поиск оптимального времени осуществлялся методом дихотомии, похожий на
предложенный в [статье][autotune-paper], за тем исключением, что начальные
значения для левой и правой границ выбираются алгоритмически,
по принципу схожим с дихотомией:

1. Пусть значение правой границы равно произвольному натуральному числу,
для простоты 2^n, n >= 0.
2. Если в результате верификации LTL-формула выполняется, то увеличиваем значение
текущей правой границы вдвое.
Предыдущее значение правой границы становится значением левой границы.
3. Повторяем шаг 2 до тех пор, пока LTL-формула перестанет выполнятся.
Значение правой границы становится равно TIME.
Для полученных значений левой и правой границ применяем формулу дихотомии из
[статьи][autotune-paper].

Т.к. на шагах 1-2 увеличиваем значение вдвое, то время работы алгоритма составит *O(log_2)*

**Таблица поиска оптимальных по времени параметров TS и WG для массива из 16 чисел:**

|№|T_MIN|LTL formula satisfiability|Real time (sec)|TIME|Steps|TS|WG|
|-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|1|+|5.74|-|-|-|-|
|2|2|+|5.73|-|-|-|-|
|3|4|+|5.76|-|-|-|-|
|4|8|+|5.8|-|-|-|-|
|5|16|+|5.83|-|-|-|-|
|6|32|-|0.003|29|1234|2|2|
|7|22|+|5.81|-|-|-|-|
|8|25|+|5.75|-|-|-|-|
|9|27|+|5.77|-|-|-|-|
|10|28|-|0.524|28|1087|4|1|

**Диаграмма последовательности:**
- GMA - global memory access
- LMA - local memory access

![img.png](docs%2Fimg.png)

[min.pml]: https://github.com/SergeyStaroletov/PromelaSamples/blob/master/autotune_opencl/min.pml
[autotune-paper]: https://arxiv.org/pdf/2305.09130

**Комментарии к решению:**
* в рамках данного этапа модель построена под возможность работы с: 1 device; 1 unit; n pex's (без warp, абстракции для барьера)
* в качестве буфера для расчета суммы использована глобальная память, результат окажется в glob[0]
* реализованны 4 LTL формулы, верификация успешно пройдена для каждой из них:
  + Когда-нибудь случится service.final (завершение подсчета суммы).
    - **ltl Fin {<> service.final }**
  + Всегда, если подсчет суммы окончен - то результат (хранится в GLOB[0]) будет равен 72 (справедливо для size=16).
    - **ltl CorrectSum {[](service.final -> (<>(GLOB[0] == 72)) )}**
  + Никогда не случится service.final
    - **ltl NonTerm {[]!service.final }**
  + Свойство сверхурочности (для поиска оптимальных параметров)
    - **ltl OverTime {[]( service.final -> (service.time > T_MIN)) }**

---

## 2-й уровень ([level_2](level_2))

В рамках 2-го уровня в модель 1-го уровня была добавлена поддержка Warp'ов для одного
Unit'а. Процесс warp инициализируется процессом unit, и, в свою очередь,
запускает процессы pex. Каждому warp'у соответствует свой участок локальной
памяти, который делится между pex'ами.

Верификация свойств *Fin*, *CorrectSum* успешно пройдена, для свойства *OverTime*
новое время работы составило **24** единицы, что меньше, чем для 1-го
уровня.
В связи с нехваткой выделенного времени, реализацию нельзя назвать полноценной, а документацию достаточно подробной. Не в рамках соревнования, планируем продолжить выполнение этой задачи вплоть до следующих уровней

---

## 3-й уровень (концепт)
Хоть мы и не успели реализовать работающую версию данного уровня, значительное время было потрачено на план реализации данной задачи и погружение в область, оставим некоторые наработки в данном документе

На этом уровне мы должны реализовать приложение на PTX в Promela, что потребует дополнительного управления масками и синхронизации потоков внутри варпа. В архитектуре SIMT, как известно, все потоки варпа выполняют одну инструкцию одновременно, но могут расходиться в разные ветви при условных операторах. Поэтому нужно эффективно работать с предикатными регистрами и масками для управления активными потоками. Помимо этого, потребуется обеспечить синхронизацию выполнения инструкций между потоками в одном варпе.

### Этапы разработки и моделирования

### Шаг 1: Определение потоков и регистров

1. **Определение процессов:**
    - Каждый поток внутри варпа моделируем как отдельный процесс (`proctype`). Важно помнить, что **все потоки варпа работают синхронно**, но их маски могут отличаться в зависимости от ветвления.

2. **Моделирование регистров PTX:**
    - Каждый регистр PTX (`%r` и `%p`) отображается на массивы переменных в Promela, по одному массиву на каждый поток в варпе.

    ```promela
    #define warp_size 32

    int r[warp_size][58];  // Массив регистров для каждого потока в варпе
    bool p[warp_size][7];  // Массив предикатных регистров для каждого потока
    ```

3. **Маска активных потоков:**
    - Для управления активностью каждого потока определим массив `active[]`. Этот массив будет содержать `true`, если поток активен, и `false`, если неактивен.

    ```promela
    bool active[warp_size];  // Маска активных потоков
    ```

4. **Инициализация потоков:**
    - Все потоки активны при старте:

    ```promela
    init {
        for (i : 0 .. warp_size-1) {
            active[i] = true;
        }
    }
    ```

### Пример: Изменение маски в зависимости от ветвления

В момент выполнения инструкции все потоки варпа активны:

- Маска: `11111111111111111111111111111111` (32 потока)

После выполнения условного оператора, например, половина потоков уходит в ветвление, и маска изменяется:

- Маска: `11111111111111110000000000000000` (только 16 потоков активны)

```promela
// Обновление предиката для каждого потока
for (i : 0 .. warp_size-1) {
    if
    :: active[i] -> p[i][1] = (r[i][4] > 0);  // Условие, которое разделяет потоки
    :: else -> skip;
    fi;
}
// Изменение маски потоков на основе предиката
update_mask(1);
```

### Шаг 2: Управление масками и предикатами

1. **Управление предикатами:**
    - Предикаты используются для условного исполнения инструкций. Например, условие `setp.eq.s32 %p2, %r35, 0;` устанавливает предикат в зависимости от значения регистра.
    - Для каждого потока вычисляем значение предиката.

    ```promela
    p[thread_id][2] = (r[thread_id][35] == 0);
    ```

2. **Изменение маски при условных переходах:**
    - После вычисления предикатов, нужно обновить маску активных потоков. Это необходимо для того, чтобы в следующем блоке кода работали только те потоки, для которых предикат истинный.

    ```promela
    inline update_mask(pred_index) {
        for (i : 0 .. warp_size-1) {
            if
            :: p[i][pred_index] -> active[i] = true;
            :: else -> active[i] = false;
            fi;
        }
    }
    ```

3. **Сохранение и восстановление маски:**
    - Для поддержки вложенных ветвлений используется стек масок. При входе в ветвление сохраняем текущую маску в стек, а при выходе восстанавливаем.

    ```promela
    bool mask_stack[MAX_DEPTH][warp_size];  // Стек масок
    int sp = 0;  // Указатель на вершину стека

    inline save_mask() {
        atomic {
            for (i : 0 .. warp_size-1) {
                mask_stack[sp][i] = active[i];
            }
            sp++;
        }
    }

    inline restore_mask() {
        atomic {
            sp--;
            for (i : 0 .. warp_size-1) {
                active[i] = mask_stack[sp][i];
            }
        }
    }
    ```
### Пример: Сложный случай ветвлений
Если в одном варпе часть потоков исполняет одну ветвь, а часть — другую, маска может меняться на каждом шаге.

Например, сначала половина потоков исполняет первую ветвь:
+ Маска: 11111111111111110000000000000000 (16 потоков активны)
Затем в этой ветви остаются только 8 потоков:
+ Маска: 11111111000000000000000000000000 (8 потоков активны)
После восстановления маски возвращаются все потоки, которые были активны до входа в ветвление:
+ Маска: 11111111111111110000000000000000

### Обновления маски на основе предикатов:
```promela
// Обновляем предикат
for (i : 0 .. warp_size-1) {
    if
    :: active[i] -> p[i][2] = (r[i][35] == 0);
    :: else -> skip;
    fi;
}

// Обновляем маску активных потоков
update_mask(2);
```
### Сложный случай ветвлений
```promela
save_mask();  // Сохраняем маску перед входом в ветвление
update_mask(1);  // Обновляем маску на основе предиката

// Выполняем ветвление с измененной маской
for (i : 0 .. warp_size-1) {
    if
    :: active[i] -> r[i][36] = r[i][34] + 10;  // Пример выполнения инструкции
    :: else -> skip;
    fi;
}

restore_mask();  // Восстанавливаем маску
```

### Шаг 3: Синхронизация потоков и одновременное выполнение инструкций
Одновременное выполнение инструкций
+ По заданию необходимо изменить работу со временем, чтобы все потоки одного варпа одновременно выполняли одну инструкцию PTX.
+ Этого можно достигнуть с помощью механизма синхронизации, так мы сможем гарантировать, что все потоки исполнили текущую инструкцию, прежде чем перешли к следующей.

1. **Механизм синхронизации:**
    - В PTX потоки в одном варпе должны выполнять инструкции синхронно. В Promela мы можем моделировать это с помощью барьеров синхронизации. Барьер гарантирует, что все потоки завершили выполнение инструкции, прежде чем продолжить.

    ```promela
    int sync_count = 0;  // Счетчик синхронизации

    inline bar_sync() {
        atomic {
            sync_count++;
            if
            :: sync_count == warp_size -> sync_count = 0;  // Все потоки синхронизировались
            :: else -> skip;
            fi;
        }
    }
    ```

2. **Пример синхронизации между потоками:**

    ```promela
    for (i : 0 .. warp_size-1) {
        if
        :: active[i] -> 
            r[i][56] = r[i][34] + r[i][36];  // Пример выполнения инструкции
        :: else -> skip;
        fi;
    }
    bar_sync();  // Синхронизация всех потоков
    ```

---

### Пример: Сложный случай ветвлений
+ Допустим, что 16 потоков выполняют одну инструкцию, а другие ожидают. При использовании синхронизации гарантируется, что все потоки завершат выполнение перед продолжением.
+ Маска: 11111111111111110000000000000000 (16 потоков активны)
+ Все потоки должны синхронизироваться перед следующим шагом:
```promela
for (i : 0 .. warp_size-1) {
    if
    :: active[i] -> r[i][56] = r[i][34] + r[i][36];  // Выполняют активные потоки
    :: else -> skip;
    fi;
}
bar_sync();  // Ожидаем, пока все потоки завершат инструкцию
```

### Шаг 4: Моделирование выполнения инструкций

1. **Моделирование конкретных инструкций PTX:**
    - Инструкции PTX могут быть смоделированы через разные подходы. Например:

    ```ptx
    add.s32 %r20, %r18, %r15;
    ```

    Соответствует:

    ```promela
    r[thread_id][20] = r[thread_id][18] + r[thread_id][15];
    ```

2. **Пример условного ветвления с предикатами:**

    ```ptx
    setp.gt.s32 %p1, %r4, 0;
    @%p1 bra BB0_2;
    ```

    В Promela:

    ```promela
    p[thread_id][1] = (r[thread_id][4] > 0);

    if
    :: p[thread_id][1] -> goto BB0_2;
    :: else -> skip;
    fi;
    ```

---

### Шаг 5: Основной цикл работы потока

1. **Каждый поток выполняет инструкции в зависимости от своей маски.**
    - Внутри цикла потока проверяется активность, и если поток активен, он выполняет свою инструкцию.

    ```promela
    proctype warp_thread(byte thread_id) {
        do
        :: is_active(thread_id) -> 
            // Выполнение инструкции
            r[thread_id][56] = r[thread_id][34] + r[thread_id][36];
            bar_sync();  // Синхронизация всех потоков
        :: else -> break;
        od;
    }
    ```

---

### Шаг 6: Вызов функций и выполнение цикла

1. **Основной процесс инициализирует варпы и запускает потоки.**

    ```promela
    init {
        // Инициализация потоков
        atomic {
            for (i : 0 .. warp_size-1) {
                run warp_thread(i);
            }
        }
    }
    ```

### Заключение (level 3)
На этом уровне мы описали план и наработки по моделированию выполнения программы на PTX. Основные тезисы для реализации:
- **Работа с масками**: использование предикатов и масок для управления активными потоками.
- **Синхронизация потоков**: все потоки варпа должны быть синхронизированы для совместного выполнения.
- **Управление стеком масок**: для поддержки вложенных ветвлений.
---
