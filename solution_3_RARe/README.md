# -veha2024

## 1-й уровень

Для решения задачи первого уровня был взят авторский вариант модели поиска
минимума: [min.pml].

Поиск оптимального времени осуществлялся методом дихотомии, похожий на
предложенный в [статье][autotune-paper], за тем исключением, что начальные
значения для левой и правой границ выбираются алгоритмически,
по принципу схожим с дихотомией:

1. Пусть значение правой границы равно произвольному натуральному числу,
для простоты 2^n, n >= 0.
2. Если в результате верификации LTL-формула выполняется, то увеличиваем значение
текущей правой границы вдвое.
Предыдущее значение правой границы становится значением левой границы.
3. Повторяем шаг 2 до тех пор, пока LTL-формула перестанет выполнятся.
Значение правой границы становится равно TIME.
Для полученных значений левой и правой границ применяем формулу дихотомии из
[статьи][autotune-paper].

Т.к. на шагах 1-2 увеличиваем значение вдвое, то время работы алгоритма составит *O(log_2)*

**Таблица поиска оптимальных по времени параметров TS и WG для массива из 16 чисел:**

|№|T_MIN|LTL formula satisfiability|Real time (sec)|TIME|Steps|TS|WG|
|-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|1|+|5.74|-|-|-|-|
|2|2|+|5.73|-|-|-|-|
|3|4|+|5.76|-|-|-|-|
|4|8|+|5.8|-|-|-|-|
|5|16|+|5.83|-|-|-|-|
|6|32|-|0.003|29|1234|2|2|
|7|22|+|5.81|-|-|-|-|
|8|25|+|5.75|-|-|-|-|
|9|27|+|5.77|-|-|-|-|
|10|28|-|0.524|28|1087|4|1|

**Диаграмма последовательности:**
- GMA - global memory access
- LMA - local memory access

![img.png](docs%2Fimg.png)

[min.pml]: https://github.com/SergeyStaroletov/PromelaSamples/blob/master/autotune_opencl/min.pml
[autotune-paper]: https://arxiv.org/pdf/2305.09130

**Комментарии к решению:**
* в рамках данного этапа модель построена под возможность работы с: 1 device; 1 unit; n pex's (без warp, абстракции для барьера)
* в качестве буфера для расчета суммы использована глобальная память, результат окажется в glob[0]
* реализованны 4 LTL формулы, верификация успешно пройдена для каждой из них:
  + Когда-нибудь случится service.final (завершение подсчета суммы).
    - **ltl Fin {<> service.final }**
  + Всегда, если подсчет суммы окончен - то результат (хранится в GLOB[0]) будет равен 72 (справедливо для size=16).
    - **ltl CorrectSum {[](service.final -> (<>(GLOB[0] == 72)) )}**
  + Никогда не случится service.final
    - **ltl NonTerm {[]!service.final } **
  + Свойство сверхурочности (для поиска оптимальных параметров)
    - **ltl OverTime {[]( service.final -> (service.time > T_MIN)) }**


## 2-й уровень

В рамках 2-го уровня в модель 1-го уровня была добавлена поддержка Warp'ов для одного
Unit'а. Процесс warp инициализируется процессом unit, и, в свою очередь,
запускает процессы pex. Каждому warp'у соответствует свой участок локальной
памяти, который делится между pex'ами.

Верификация свойств *Fin*, *CorrectSum* успешно пройдена, для свойства *OverTime*
новое время работы составило **24** единицы, что составило меньше, чем для 1-го
уровня.
В связи с нехваткой выделенного времени, реализацию нельзя назвать полноценной, а документацию достаточно подробной. Не в рамках соревнования, ссылаясь на наш энтузиазм - планируем продолжить выполнение этой задачи вплоть до следующих уровней :)


P.S. Разработка велась в отдельном приватном github-репозитории. При необходимости - можем предоставить доступ для наглядности процесса разработки, через просмотр коммитов 
